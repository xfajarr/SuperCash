/// Utility functions for SuperCash payments system
/// Optimized cryptographic operations and helper functions
module supercash::utils {
    use std::vector;
    use std::bcs;
    use std::from_bcs;
    use aptos_framework::timestamp;
    use std::hash;
    
    /// Create a cryptographic commitment for link-based transfers
    /// Uses SHA3-256 for security and consistency
    /// Format: SHA3(secret || amount || nonce || expiry || sender_addr)
    public fun create_commitment(
        secret: vector<u8>,
        amount: u64,
        nonce: u64, 
        expiry: u64,
        sender_addr: address
    ): vector<u8> {
        let commitment_data = vector::empty<u8>();
        
        // Append secret (32 bytes)
        commitment_data.append(secret);
        
        // Append amount as 8 bytes (little-endian)
        let amount_bytes = u64_to_bytes(amount);
        commitment_data.append(amount_bytes);
        
        // Append nonce as 8 bytes
        let nonce_bytes = u64_to_bytes(nonce);
        commitment_data.append(nonce_bytes);
        
        // Append expiry as 8 bytes
        let expiry_bytes = u64_to_bytes(expiry);
        commitment_data.append(expiry_bytes);
        
        // Append sender address (32 bytes)
        let sender_bytes = address_to_bytes(sender_addr);
        commitment_data.append(sender_bytes);
        
        // Return SHA3-256 hash
        hash::sha3_256(commitment_data)
    }
    
    /// Verify a commitment against provided parameters
    public fun verify_commitment(
        commitment: vector<u8>,
        secret: vector<u8>,
        amount: u64,
        nonce: u64,
        expiry: u64,
        sender_addr: address
    ): bool {
        let computed = create_commitment(secret, amount, nonce, expiry, sender_addr);
        commitment == computed
    }
    
    /// Convert u64 to little-endian byte array
    public fun u64_to_bytes(value: u64): vector<u8> {
        let bytes = vector::empty<u8>();
        let i = 0;
        while (i < 8) {
            let byte = ((value >> (i * 8)) & 0xFF as u8);
            bytes.push_back(byte);
            i += 1;
        };
        bytes
    }
    
    /// Convert address to byte array
    public fun address_to_bytes(addr: address): vector<u8> {
        // Use built-in address serialization
        bcs::to_bytes(&addr)
    }
    
    /// Generate a unique object address from commitment hash
    /// This ensures each link transfer gets a unique object address
    public fun commitment_to_object_address(commitment: vector<u8>): address {
        // Use a simpler approach - just use the commitment as seed
        // In practice, this would be handled by the object creation process
        @0x0  // Placeholder - actual object addresses are generated by the framework
    }
    
    /// Check if a timestamp is expired
    public fun is_expired(expiry: u64): bool {
        timestamp::now_seconds() > expiry
    }
    
    /// Generate a secure random nonce using block information
    /// This provides good entropy for preventing collisions
    public fun generate_nonce(sender: address, extra_entropy: vector<u8>): u64 {
        let nonce_data = vector::empty<u8>();
        
        // Use current timestamp
        let ts = timestamp::now_seconds();
        nonce_data.append(u64_to_bytes(ts));
        
        // Use sender address
        nonce_data.append(address_to_bytes(sender));
        
        // Use extra entropy from caller
        nonce_data.append(extra_entropy);
        
        // Hash and convert to u64
        let hash_result = hash::sha3_256(nonce_data);
        bytes_to_u64(hash_result)
    }
    
    /// Convert first 8 bytes of hash to u64
    fun bytes_to_u64(bytes: vector<u8>): u64 {
        let result = 0u64;
        let i = 0;
        let len = bytes.length();
        let max_bytes = if (len < 8) len else 8;
        
        while (i < max_bytes) {
            let byte = bytes[i];
            result += ((byte as u64) << ((i * 8) as u8));
            i += 1;
        };
        result
    }
    
    /// Batch multiple operations to reduce transaction overhead
    public fun batch_hash(items: vector<vector<u8>>): vector<vector<u8>> {
        let results = vector::empty<vector<u8>>();
        let len = items.length();
        let i = 0;
        
        while (i < len) {
            let item = items.borrow(i);
            let hash = hash::sha3_256(*item);
            results.push_back(hash);
            i += 1;
        };
        
        results
    }
}